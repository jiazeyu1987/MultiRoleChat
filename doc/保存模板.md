# 流程模板「保存模板」数据流说明

本文档说明在「流程模板」页面点击【保存模板】按钮时，前端、后端与数据库之间的数据格式与流转过程，便于调试和扩展。

---

## 一、前端 → 后端：保存模板请求

### 1. 调用链

- 入口组件：`fronted/src/MultiRoleDialogSystem.tsx` 中的 `FlowManagement` / `FlowEditor`
- 保存按钮：`FlowEditor` 内部：

  ```tsx
  <Button onClick={() => onSave({ ...data, steps })} icon={Save}>保存模板</Button>
  ```

- `FlowManagement` 中对 `onSave` 的实现（核心逻辑）大致为：

  ```tsx
  if (editingFlow) {
    return <FlowEditor flow={editingFlow} onSave={async (flow: any) => {
      // 日志快照
      formatTemplateForLog(flow);

      // 判断是创建还是更新
      const isUpdate = flow.id && flow.id > 0;

      // 规范化步骤：去掉前端临时 id 字段
      const normalizedSteps = (flow.steps || []).map((step: any) => {
        const { id, ...rest } = step;
        return rest;
      });

      let result;
      if (isUpdate) {
        result = await flowApi.updateFlow(flow.id, {
          name: flow.name,
          topic: flow.topic,
          type: flow.type || 'teaching',
          description: flow.description,
          version: flow.version,
          is_active: flow.is_active,
          termination_config: flow.termination_config,
          steps: normalizedSteps,
        });
      } else {
        result = await flowApi.createFlow({
          name: flow.name,
          topic: flow.topic,
          type: flow.type || 'teaching',
          description: flow.description,
          version: flow.version,
          is_active: flow.is_active,
          termination_config: flow.termination_config,
          steps: normalizedSteps,
        });
      }

      await fetchFlows();
      setEditingFlow(null);
    }} .../>
  }
  ```

### 2. API 客户端与 URL

定义位置：`fronted/src/api/flowApi.ts`

- 创建模板：

  ```ts
  async createFlow(flowData: FlowTemplateRequest): Promise<FlowTemplate> {
    return apiClient.post<FlowTemplate>('/api/flows', flowData);
  }
  ```

- 更新模板：

  ```ts
  async updateFlow(id: number, flowData: Partial<FlowTemplateRequest>): Promise<FlowTemplate> {
    return apiClient.put<FlowTemplate>(`/api/flows/${id}`, flowData);
  }
  ```

底层 HTTP 客户端定义在 `fronted/src/api/roleApi.ts` 中的 `ApiClient`：

- `baseURL` 默认：`http://localhost:5010`（或由 `VITE_API_BASE_URL` 相关变量配置）
- `request` 方法统一发送 JSON 请求，解析标准后端响应包。

### 3. 前端请求 JSON 结构

#### 3.1 模板请求类型：`FlowTemplateRequest`

定义：`fronted/src/api/flowApi.ts`

```ts
export interface FlowTemplateRequest {
  name: string;
  topic?: string;
  type: 'teaching' | 'review' | 'debate' | 'discussion' | 'interview' | 'other';
  description?: string;
  version?: string;
  is_active?: boolean;
  termination_config?: Record<string, any>;
  steps?: Omit<FlowStep, 'id' | 'flow_template_id'>[];
}
```

#### 3.2 步骤请求类型：`FlowStep`（前端）

在 `MultiRoleDialogSystem.tsx` 中（用于 UI）：

```ts
interface FlowStep {
  id: number;                  // 前端临时 ID（不会发给后端）
  order: number;               // 步骤顺序（1 开始，连续）
  speaker_role_ref: string;    // 说话角色引用（角色名称）
  target_role_ref?: string;    // 目标角色引用（可为 '__TOPIC__' 或角色名）
  task_type: 'ask_question' | 'answer_question' | 'comment' | string;
  context_scope: 'all' | 'last_n_messages' | string | string[];
  context_param?: { n: number };
  logic_config?: {
    next_step_order?: number;
    exit_condition?: string;
    max_loops?: number;
  };
}
```

在 API 层（`fronted/src/api/flowApi.ts`）用于类型约束：

```ts
export interface FlowStep {
  id: number;
  flow_template_id: number;
  order: number;
  speaker_role_ref: string;
  target_role_ref?: string;
  task_type:
    | 'ask_question'
    | 'answer_question'
    | 'review_answer'
    | 'question'
    | 'summarize'
    | 'evaluate'
    | 'suggest'
    | 'challenge'
    | 'support'
    | 'conclude';
  context_scope: string | string[];
  context_param?: Record<string, any>;
  logic_config?: Record<string, any>;
  next_step_id?: number;
  description?: string;
}
```

> 注意：实际请求中，`normalizedSteps` 已去掉 `id` 字段，`flow_template_id` 也由后端赋值。

#### 3.3 示例：创建模板请求体

```json
{
  "name": "新对话流程",
  "topic": "某个教学场景",
  "type": "teaching",
  "description": "",
  "version": "1.0.0",
  "is_active": true,
  "termination_config": {},
  "steps": [
    {
      "order": 1,
      "speaker_role_ref": "Teacher",
      "target_role_ref": null,
      "task_type": "ask_question",
      "context_scope": "all",
      "context_param": {},
      "logic_config": {
        "next_step_order": 2,
        "exit_condition": "student_answer_correct",
        "max_loops": 3
      },
      "description": "老师提问"
    }
  ]
}
```

---

## 二、后端：API 层与服务层数据格式

### 1. API 路由

定义位置：`backend/app/__init__.py` 中的 `register_api`：

- 创建/列表/详情/更新/删除流程模板：
  - `POST   /api/flows`           → 创建模板
  - `GET    /api/flows`           → 分页列表（不含 steps）
  - `GET    /api/flows/<id>`      → 模板详情（含 steps）
  - `PUT    /api/flows/<id>`      → 更新模板
  - `DELETE /api/flows/<id>`      → 软删除模板

具体实现：`backend/app/api/flows.py`

### 2. 请求校验层（Schema）

#### 2.1 模板创建/更新 Schema

文件：`backend/app/schemas/flow_request.py`

```py
class FlowTemplateCreateSchema(Schema):
    name = fields.String(required=True, validate=Length(1, 200))
    topic = fields.String(validate=Length(max=200))
    type = fields.String(required=True, validate=OneOf(
        ['teaching', 'review', 'debate', 'discussion', 'interview', 'other']
    ))
    description = fields.String(validate=Length(max=1000))
    version = fields.String(validate=Length(max=20))
    is_active = fields.Boolean()
    termination_config = fields.Dict()
    steps = fields.List(fields.Nested(FlowStepSchema()), required=False)
```

更新时 `FlowTemplateUpdateSchema` 结构相同，但字段均为可选。

#### 2.2 步骤 Schema：`FlowStepSchema`

文件：`backend/app/schemas/flow.py`

```py
class FlowStepSchema(Schema):
    id = fields.Integer(dump_only=True)
    flow_template_id = fields.Integer(dump_only=True)
    order = fields.Integer(required=True, validate=Range(min=1))
    speaker_role_ref = fields.String(required=True, validate=Length(min=1, max=50))
    target_role_ref = fields.String(validate=Length(max=50))
    task_type = fields.String(required=True)
    context_scope = fields.Raw(required=True)

    # 以下字段实际保存在 DB 文本列中，通过 *_dict 属性映射为 dict
    context_param = fields.Dict(attribute='context_param_dict')
    logic_config = fields.Dict(attribute='logic_config_dict')
    loop_config = fields.Dict(attribute='loop_config_dict')
    condition_config = fields.Dict(attribute='condition_config_dict')

    next_step_id = fields.Integer(allow_none=True)
    description = fields.String(validate=Length(max=500))
```

`load` 方法会做一些兼容处理：

- `context_scope`：如果是数组/对象，序列化为 JSON 字符串保存；否则转为字符串；
- 如果存在 `loop_config` / `condition_config` 且没有显式 `logic_config`，会自动合并到 `logic_config`。

### 3. 服务层：创建/更新模板

文件：`backend/app/services/flow_service.py`

#### 3.1 创建模板 `create_template`

核心逻辑：

```py
def create_template(template_data: Dict[str, Any], user_id: Optional[int] = None) -> FlowTemplate:
    # 组装 FlowTemplate 基本信息
    template_info = {
        'name': template_data['name'],
        'type': template_data['type'],
        'description': template_data.get('description', ''),
        'version': template_data.get('version', '1.0.0'),
        'is_active': template_data.get('is_active', True),
    }
    if 'topic' in template_data:
        template_info['topic'] = template_data['topic']

    template = FlowTemplate(**template_info)

    # 终止条件
    if 'termination_config' in template_data:
        template.termination_config_dict = template_data['termination_config']

    db.session.add(template)
    db.session.flush()  # 获得 template.id

    # 创建步骤
    steps_data = template_data.get('steps', [])
    if steps_data:
        FlowTemplateService._create_template_steps(template.id, steps_data)

    db.session.commit()
    return template
```

#### 3.2 创建步骤 `_create_template_steps`

核心逻辑（省略日志）：

```py
def _create_template_steps(template_id: int, steps_data: List[Dict[str, Any]]) -> None:
    FlowTemplateService._validate_steps_data(steps_data)

    steps = []
    for step_data in steps_data:
        # 处理 context_scope：如果是 list/dict，则序列化为 JSON 字符串
        context_scope = step_data.get('context_scope')
        if isinstance(context_scope, (list, dict)):
            context_scope = json.dumps(context_scope, ensure_ascii=False)
        else:
            context_scope = str(context_scope) if context_scope is not None else ''

        # 处理 logic_config：确保是 dict
        logic_config = step_data.get('logic_config') or {}
        if not isinstance(logic_config, dict):
            try:
                if isinstance(logic_config, str):
                    parsed = json.loads(logic_config)
                    logic_config = parsed if isinstance(parsed, dict) else {}
                else:
                    logic_config = dict(logic_config)
            except Exception:
                logic_config = {}

        step = FlowStep(
            flow_template_id=template_id,
            order=step_data['order'],
            speaker_role_ref=step_data['speaker_role_ref'],
            target_role_ref=step_data.get('target_role_ref'),
            task_type=step_data['task_type'],
            context_scope=context_scope,
            context_param_dict=step_data.get('context_param', {}),
            logic_config_dict=logic_config,
            loop_config_dict=step_data.get('loop_config', {}),
            condition_config_dict=step_data.get('condition_config', {}),
            next_step_id=step_data.get('next_step_id'),
            description=step_data.get('description', ''),
        )
        steps.append(step)

    db.session.add_all(steps)
```

#### 3.3 步骤数据验证 `_validate_steps_data`

同文件中：

```py
required_fields = ['order', 'speaker_role_ref', 'task_type', 'context_scope']
valid_task_types = [
    'ask_question', 'answer_question', 'review_answer', 'question',
    'summarize', 'evaluate', 'suggest', 'challenge', 'support', 'conclude',
    'comment',  # 为兼容前端
]
base_context_scopes = ['none', 'last_message', 'last_round', 'last_n_messages', 'all']
system_context_scopes = ['__TOPIC__']

for step in steps_data:
    for field in required_fields:
        if field not in step:
            raise StepValidationError(f"步骤缺少必要字段: {field}")

    if step['task_type'] not in valid_task_types:
        raise StepValidationError(f"无效的任务类型: {step['task_type']}")

    scope = step['context_scope']
    # 允许基础范围/系统范围/单角色名/角色数组（JSON 字符串或数组）
    # last_n_messages 时必须提供 context_param.n
```

---

## 三、后端 → 前端：保存成功响应

### 1. 创建成功响应结构

在 `FlowList.post` 中：

```py
return {
    'success': True,
    'data': result,       # FlowTemplateSchema.dump(template)
    'message': '流程模板创建成功',
}, 201
```

`FlowTemplateSchema`（`backend/app/schemas/flow.py`）：

```py
class FlowTemplateSchema(Schema):
    id = fields.Integer(dump_only=True)
    name = fields.String(required=True, ...)
    topic = fields.String(...)
    type = fields.String(required=True, validate=OneOf([...]))
    description = fields.String(...)
    version = fields.String(...)
    is_active = fields.Boolean()
    termination_config = fields.Dict(attribute='termination_config_dict')
    created_at = fields.DateTime(dump_only=True)
    updated_at = fields.DateTime(dump_only=True)
    steps = fields.List(fields.Nested(FlowStepSchema()), dump_only=True)
    step_count = fields.Integer(dump_only=True)
```

因此，`POST /api/flows` 成功返回的数据结构形如：

```json
{
  "success": true,
  "data": {
    "id": 42,
    "name": "新对话流程",
    "topic": "111",
    "type": "teaching",
    "description": "",
    "version": "1.0.0",
    "is_active": true,
    "termination_config": {},
    "created_at": "2025-12-03T11:27:07.940101",
    "updated_at": "2025-12-03T11:27:07.940105",
    "step_count": 1,
    "steps": [
      {
        "id": 60,
        "flow_template_id": 42,
        "order": 1,
        "speaker_role_ref": "Quality Manager",
        "target_role_ref": null,
        "task_type": "ask_question",
        "context_scope": "all",
        "context_param": {},
        "logic_config": {},          // 目前你看到的问题就出在这里是空
        "next_step_id": null,
        "description": ""
      }
    ]
  },
  "message": "流程模板创建成功"
}
```

### 2. 模板详情响应结构

`GET /api/flows/<id>`（`FlowDetail.get`）：

- 查询：`FlowTemplateService.get_template_by_id(flow_id, include_steps=True)`
- 使用 `FlowTemplateSchema` 进行序列化；结构与上面的 `data` 基本一致。

前端在编辑时通过：

```ts
const fullFlow = await flowApi.getFlow(flow.id);
setEditingFlow(fullFlow);
```

然后 `FlowEditor` 中：

```ts
const [data, setData] = useState(flow);
const [steps, setSteps] = useState<FlowStep[]>(flow.steps || []);

useEffect(() => {
  setData(flow);
  setSteps(flow.steps || []);
}, [flow]);
```

将后端返回的 `steps.logic_config` 映射回 UI 控件。  
如果后端返回的是 `logic_config: {}`，则“流转逻辑配置”区域自然为空。

---

## 四、数据库表结构

### 1. `flow_templates` 表

模型：`backend/app/models/flow.py` 中的 `FlowTemplate`

```py
class FlowTemplate(db.Model):
    __tablename__ = 'flow_templates'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(200), nullable=False)
    topic = db.Column(db.String(200))
    type = db.Column(db.String(50), nullable=False)
    description = db.Column(db.Text)
    version = db.Column(db.String(20), default='1.0.0')
    is_active = db.Column(db.Boolean, default=True)
    termination_config = db.Column(db.Text)  # JSON 字符串
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    steps = db.relationship('FlowStep', lazy='dynamic', order_by='FlowStep.order')
```

字段说明：

- `termination_config` 实际存储为 JSON 字符串，通过 `termination_config_dict` 属性以 dict 方式读写。

### 2. `flow_steps` 表

模型：`backend/app/models/flow.py` 中的 `FlowStep`

```py
class FlowStep(db.Model):
    __tablename__ = 'flow_steps'

    id = db.Column(db.Integer, primary_key=True)
    flow_template_id = db.Column(db.Integer, db.ForeignKey('flow_templates.id'), nullable=False)
    order = db.Column(db.Integer, nullable=False)
    speaker_role_ref = db.Column(db.String(50), nullable=False)
    target_role_ref = db.Column(db.String(50))
    task_type = db.Column(db.String(50), nullable=False)
    context_scope = db.Column(db.Text, nullable=False)
    context_param = db.Column(db.Text)          # JSON 字符串
    logic_config = db.Column(db.Text)           # JSON 字符串
    loop_config = db.Column(db.Text)            # JSON 字符串（兼容旧字段）
    condition_config = db.Column(db.Text)       # JSON 字符串（兼容旧字段）
    next_step_id = db.Column(db.Integer, db.ForeignKey('flow_steps.id'))
    description = db.Column(db.String(500))
```

相关属性方法：

- `context_param_dict` / `loop_config_dict` / `condition_config_dict` / `logic_config_dict`：
  - 读取时：`json.loads` + 类型校验，保证对外是 `dict` 或 `{}`；
  - 设置时：接收 `dict`，存入对应的 `Text` 列（JSON 字符串）；
  - `logic_config_dict` 会优先解析 `logic_config`，若为空则尝试从 `loop_config_dict` / `condition_config_dict` 合并。

- `context_scope_value`：
  - 读取时：尝试 `json.loads(context_scope)`，如果是数组则返回数组，否则返回原始字符串；
  - 设置时：接收字符串或数组/对象，数组/对象会序列化为 JSON 字符串存入 `context_scope`。


---

## 五、小结与调试建议

1. **前端保存请求格式**：
   - URL：`POST /api/flows`（创建）或 `PUT /api/flows/<id>`（更新）；
   - 关键字段：`name`、`topic`、`type`、`is_active`、`termination_config`、`steps[*]`；
   - `steps[*].logic_config` 需要在点击“保存模板”前已写入前端 `steps` 状态，否则最终传给后端的就是 `{}`。

2. **后端校验与存储**：
   - `FlowTemplateCreateSchema` / `FlowStepSchema` 保证字段结构合法；
   - `_validate_steps_data` 限制 `task_type` 和 `context_scope` 的取值；
   - `_create_template_steps` 将 `logic_config` 等字段规范为 dict 再落库为 JSON 字符串。

3. **编辑时恢复数据**：
   - 编辑入口会调用 `GET /api/flows/<id>` 获取完整模板详情；
   - `FlowEditor` 通过 `useEffect([flow])` 将返回的 `flow.steps` 同步到本地 `steps`，再通过 `step.logic_config.xxx` 显示“流转逻辑配置”。

4. **排查“流转逻辑配置丢失”时建议**：
   - 在浏览器 Network 中检查 `POST /api/flows` 请求体里 `steps[*].logic_config` 是否有值；
   - 对比后端日志中的“原始请求数据”和“步骤数据”日志，确认后端是否收到并落库；
   - 使用 `GET /api/flows/<id>` 对照查看返回的 `steps[*].logic_config` 是否为空。

